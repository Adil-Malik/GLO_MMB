/* 
Adil Malik 06/01/2014
GLO: The Midnight Message Board
V1
*/
byte font [][8] =
{
	
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 032 ( )
	{0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 033 (!)
	{0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00},	// Char 034 (")
	{0x14, 0x3E, 0x14, 0x3E, 0x14, 0x00, 0x00, 0x00},	// Char 035 (#)
	{0x17, 0x15, 0x3F, 0x1D, 0x00, 0x00, 0x00, 0x00},	// Char 036 ($)
	{0x26, 0x16, 0x08, 0x34, 0x32, 0x00, 0x00, 0x00},	// Char 037 (%)
	{0x36, 0x2A, 0x36, 0x08, 0x34, 0x00, 0x00, 0x00},	// Char 038 (&)
	{0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 039 (')
	{0x00, 0x1C, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 040 (()
	{0x00, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 041 ())
	{0x0A, 0x04, 0x1F, 0x04, 0x0A, 0x00, 0x00, 0x00},	// Char 042 (*)
	{0x00, 0x08, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00},	// Char 043 (+)
	{0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 044 (,)
	{0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00},	// Char 045 (-)
	{0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 046 (.)
	{0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00},	// Char 047 (/)
	{0x00, 0x3E, 0x22, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 048 (0)
	{0x00, 0x02, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 049 (1)
	{0x00, 0x3A, 0x2A, 0x2E, 0x00, 0x00, 0x00, 0x00},	// Char 050 (2)
	{0x00, 0x2A, 0x2A, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 051 (3)
	{0x00, 0x0E, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 052 (4)
	{0x00, 0x2E, 0x2A, 0x3A, 0x00, 0x00, 0x00, 0x00},	// Char 053 (5)
	{0x00, 0x3E, 0x2A, 0x3A, 0x00, 0x00, 0x00, 0x00},	// Char 054 (6)
	{0x00, 0x06, 0x02, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 055 (7)
	{0x00, 0x3E, 0x2A, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 056 (8)
	{0x00, 0x2E, 0x2A, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 057 (9)
	{0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 058 (:)
	{0x00, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 059 (;)
	{0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00},	// Char 060 (<)
	{0x00, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00},	// Char 061 (=)
	{0x00, 0x00, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00},	// Char 062 (>)
	{0x00, 0x02, 0x2A, 0x06, 0x00, 0x00, 0x00, 0x00},	// Char 063 (?)
	{0x3E, 0x41, 0x49, 0x55, 0x55, 0x5D, 0x1E, 0x00},	// Char 064 (@)
	{0x3E, 0x09, 0x09, 0x09, 0x3E, 0x00, 0x00, 0x00},	// Char 065 (A)
	{0x3F, 0x25, 0x25, 0x25, 0x1A, 0x00, 0x00, 0x00},	// Char 066 (B)
	{0x1E, 0x21, 0x21, 0x21, 0x12, 0x00, 0x00, 0x00},	// Char 067 (C)
	{0x3F, 0x21, 0x21, 0x21, 0x1E, 0x00, 0x00, 0x00},	// Char 068 (D)
	{0x3F, 0x29, 0x29, 0x29, 0x21, 0x00, 0x00, 0x00},	// Char 069 (E)
	{0x3F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00},	// Char 070 (F)
	{0x1E, 0x21, 0x21, 0x29, 0x18, 0x00, 0x00, 0x00},	// Char 071 (G)
	{0x3F, 0x08, 0x08, 0x08, 0x3F, 0x00, 0x00, 0x00},	// Char 072 (H)
	{0x21, 0x3F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 073 (I)
	{0x10, 0x21, 0x21, 0x1F, 0x01, 0x00, 0x00, 0x00},	// Char 074 (J)
	{0x3F, 0x08, 0x14, 0x22, 0x01, 0x00, 0x00, 0x00},	// Char 075 (K)
	{0x3F, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00},	// Char 076 (L)
	{0x3F, 0x02, 0x0C, 0x02, 0x3F, 0x00, 0x00, 0x00},	// Char 077 (M)
	{0x3F, 0x02, 0x0C, 0x10, 0x3F, 0x00, 0x00, 0x00},	// Char 078 (N)
	{0x1E, 0x21, 0x21, 0x21, 0x1E, 0x00, 0x00, 0x00},	// Char 079 (O)
	{0x3F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00},	// Char 080 (P)
	{0x1E, 0x21, 0x29, 0x31, 0x1E, 0x00, 0x00, 0x00},	// Char 081 (Q)
	{0x3F, 0x09, 0x09, 0x19, 0x26, 0x00, 0x00, 0x00},	// Char 082 (R)
	{0x12, 0x25, 0x2D, 0x29, 0x12, 0x00, 0x00, 0x00},	// Char 083 (S)
	{0x01, 0x01, 0x3F, 0x01, 0x01, 0x00, 0x00, 0x00},	// Char 084 (T)
	{0x1F, 0x20, 0x20, 0x20, 0x1F, 0x00, 0x00, 0x00},	// Char 085 (U)
	{0x03, 0x0C, 0x30, 0x0C, 0x03, 0x00, 0x00, 0x00},	// Char 086 (V)
	{0x3F, 0x10, 0x0C, 0x10, 0x3F, 0x00, 0x00, 0x00},	// Char 087 (W)
	{0x21, 0x12, 0x0C, 0x12, 0x21, 0x00, 0x00, 0x00},	// Char 088 (X)
	{0x01, 0x02, 0x3C, 0x02, 0x01, 0x00, 0x00, 0x00},	// Char 089 (Y)
	{0x31, 0x29, 0x25, 0x23, 0x21, 0x00, 0x00, 0x00},	// Char 090 (Z)
	{0x00, 0x00, 0x3E, 0x22, 0x00, 0x00, 0x00, 0x00},	// Char 091 ([)
	{0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00},	// Char 092 (\)
	{0x00, 0x00, 0x22, 0x3E, 0x00, 0x00, 0x00, 0x00},	// Char 093 (])
	{0x00, 0x04, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00},	// Char 094 (^)
	{0x00, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00},	// Char 095 (_)
	{0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00},	// Char 096 (`)
	{0x10, 0x2A, 0x2A, 0x3C, 0x00, 0x00, 0x00, 0x00},	// Char 097 (a)
	{0x00, 0x3F, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00},	// Char 098 (b)
	{0x18, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 099 (c)
	{0x18, 0x24, 0x24, 0x3F, 0x00, 0x00, 0x00, 0x00},	// Char 100 (d)
	{0x1C, 0x2A, 0x2A, 0x2C, 0x00, 0x00, 0x00, 0x00},	// Char 101 (e)
	{0x08, 0x3E, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 102 (f)
	{0x04, 0x2A, 0x2A, 0x1E, 0x00, 0x00, 0x00, 0x00},	// Char 103 (g)
	{0x3F, 0x08, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 104 (h)
	{0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 105 (i)
	{0x00, 0x10, 0x20, 0x1D, 0x00, 0x00, 0x00, 0x00},	// Char 106 (j)
	{0x00, 0x3F, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00},	// Char 107 (k)
	{0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 108 (l)
	{0x38, 0x08, 0x38, 0x08, 0x30, 0x00, 0x00, 0x00},	// Char 109 (m)
	{0x00, 0x38, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00},	// Char 110 (n)
	{0x00, 0x18, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00},	// Char 111 (o)
	{0x00, 0x00, 0x3C, 0x14, 0x08, 0x00, 0x00, 0x00},	// Char 112 (p)
	{0x00, 0x08, 0x14, 0x3C, 0x00, 0x00, 0x00, 0x00},	// Char 113 (q)
	{0x00, 0x00, 0x38, 0x08, 0x08, 0x00, 0x00, 0x00},	// Char 114 (r)
	{0x00, 0x24, 0x2A, 0x2A, 0x12, 0x00, 0x00, 0x00},	// Char 115 (s)
	{0x00, 0x04, 0x3E, 0x24, 0x00, 0x00, 0x00, 0x00},	// Char 116 (t)
	{0x00, 0x18, 0x20, 0x20, 0x38, 0x00, 0x00, 0x00},	// Char 117 (u)
	{0x00, 0x18, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00},	// Char 118 (v)
	{0x00, 0x18, 0x20, 0x30, 0x20, 0x18, 0x00, 0x00},	// Char 119 (w)
	{0x00, 0x28, 0x10, 0x28, 0x00, 0x00, 0x00, 0x00},	// Char 120 (x)
	{0x00, 0x26, 0x28, 0x1E, 0x00, 0x00, 0x00, 0x00},	// Char 121 (y)
	{0x00, 0x24, 0x34, 0x2C, 0x24, 0x00, 0x00, 0x00},	// Char 122 (z)
	{0x00, 0x00, 0x08, 0x3E, 0x77, 0x41, 0x41, 0x00},	// Char 123 ({)
	{0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00},	// Char 124 (|)
	{0x41, 0x41, 0x77, 0x3E, 0x08, 0x00, 0x00, 0x00},	// Char 125 (})
	{0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00}	// Char 126 (~)
	
};
int ColumnSteps = 20;//Steps Between Columns of a single Character
int CharSteps = 20; //Steps Between Character
int Speed = 5; //Motor Time between pulses (Speed)
const int Columns = 6; // Number of columns in a single character
int latchPin = 8;
int clockPin = 11;
int dataPin = 10; 
int OEPin = 9; // Output Enable
int MCPin = 12; //Master Clear pin
int Enmtr = 4; //Motor Enable
int Dirmtr = 7; //Motor Direction Pin
int Stepmtr = 2; // Motor Step Pin
int i, j, k ,l = 0;
int BytesReceived;
int CharLine = 36; //How many Chars per line, change this as per your display size
char data[CharLine]; //Array that stores the data we send via Serial Port, its max length is set to whats possilbe see on line 1
char data2[CharLine]; //Array that stores data for line 2



void setup() {
  //set pins to output so you can control the shift register
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode(MCPin, OUTPUT);
  pinMode(OEPin, OUTPUT);
  pinMode(Dirmtr, OUTPUT);
  pinMode(Enmtr, OUTPUT);
  pinMode(Stepmtr, OUTPUT);
  analogWrite(OEPin, 0); //Set the Brightness on LEDs, you can use this to shroten or increase the Fade Time.(0==MAX, 255==MIN).
  Serial.begin(9600);
  Serial.println("Serial conection started, waiting for instructions...");

}

void loop() {

 SerialRead();  //read serial data and store character in array
 WriteOut_1(data); //First line of text
 WriteOut_2(data2);//Second line of text



}





void WriteOut_2(char message[]){


  int messageLth = strlen(message); //Find the messages length.


  for(j=0; j<=messageLth-1; j++){ //Go through each character in the message.

    int Character = message[j] - 32;//reads and stores the ASCII value of the current Character we are dealing with and -32 so the char correspnds to our array.



    for(i=0;i<Columns;i++){//Go through each column in each character.
      ClearMem(); // clears the shift register so the data doesnt overflow into the other SR
      digitalWrite(latchPin, LOW);

      shiftOut(dataPin, clockPin, MSBFIRST, (font[Character][i])>>2); //Shiftup by 2 as only 6 leds are connected to Shift Register 2
      shiftOut(dataPin, clockPin, MSBFIRST, ((B00000000) | ((font[Character][i])<<6))); //Display the first 2 bits of a column on Shift Register 1's A6 and A7. We are splitting the byte. B11001101, the first register displays the first 2 bits, ie B00000011, and the second shfit register displays the rest of the original byte, shifted up by 2 ie,B00110100   

      digitalWrite(latchPin, HIGH); 


      MotorFWD(ColumnSteps);//Move between Columns of a character
      ClearMem();
    }
    MotorFWD(CharSteps); //Move between characters

  }
  ClearMem();
  MotorRtrn((messageLth*Columns*ColumnSteps)+(CharSteps*messageLth)); //Calculate the steps back to "Home"
  memset(data2, 0, strlen(data2)); //Clear the aray (kills the loop)


}

void WriteOut_1(char message[]){


  int messageLth = strlen(message); //Find the messages length.


  for(j=0; j<=messageLth-1; j++){ //Go through each character in the message.

    int Character = message[j] - 32;//reads and stores the ASCII value of the current Character we are dealing with and -32 so the char correspnds to our array.



    for(i=0;i<Columns;i++){//Go through each column in each character.
      ClearMem(); // clears the shift register so the data doesnt overflow into the other SR
      digitalWrite(latchPin, LOW);

      shiftOut(dataPin, clockPin, MSBFIRST, (font[Character][i])); //Shiftup by 2 as only 6 leds are connected to Shift Register 2
     // shiftOut(dataPin, clockPin, MSBFIRST, ((B00000000) | ((font[Character][i])<<6))); //Display the first 2 bits of a column on Shift Register 1's A6 and A7. We are splitting the byte. B11001101, the first register displays the first 2 bits, ie B00000011, and the second shfit register displays the rest of the original byte, shifted up by 2 ie,B00110100   

      digitalWrite(latchPin, HIGH); 


      MotorFWD(ColumnSteps);//Move between Columns of a character
      ClearMem();
    }
    MotorFWD(CharSteps); //Move between characters

  }
  ClearMem();
  MotorRtrn((messageLth*Columns*ColumnSteps)+(CharSteps*messageLth)); //Calculate the steps back to "Home"
  memset(data, 0, strlen(data)); //Clear the aray (kills the loop)


}




void ClearMem(){ //Clear both Shift Registers.
  digitalWrite(MCPin,LOW);
  delay(10); 
  digitalWrite(MCPin,HIGH);
}

void SerialRead(){
  if(Serial.available() > 0)
  {
    BytesReceived = Serial.readBytesUntil (13,data,CharLine-1); //Read 35 Bytes from the buffer or untill ASCII Char 13 found. Store in array "data" 
    data[BytesReceived] = 0; // add a 0 terminator 
    Serial.println(data);
    delay(100);
    BytesReceived = Serial.readBytesUntil (13,data2,CharLine-1); //Read 35 Bytes from the buffer or untill ASCII Char 13 found. Store in array "data2" 
    data2[BytesReceived] = 0; // add a 0 terminator
    Serial.println(data2);
  }


}

void MotorFWD(int steps){
  digitalWrite(Enmtr,LOW); //turn motor on
  digitalWrite(Dirmtr,LOW); // Set Direction of motor to Right
  for (k=0;k<steps;k++){
    digitalWrite(Stepmtr,LOW);
    delay(Speed);
    digitalWrite(Stepmtr,HIGH);
  }

}
void MotorRtrn(int steps){

  digitalWrite(Dirmtr,HIGH); //Set direction of motor to Left
  for (l=0;l<steps;l++){
    digitalWrite(Stepmtr,LOW);
    delay(Speed);
    digitalWrite(Stepmtr,HIGH);

  }
  digitalWrite(Enmtr,HIGH);//turn off motor
}



